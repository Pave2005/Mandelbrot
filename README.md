# SIMD-оптимизация расчета множества Мандельброта.
![](mandelbrot.jpg)
## Описание поставленной задачи.
Целью работы было написание трех функций для расчета множества Мандельброта.

Первая представляет из себя программу, которая в цикле рассчитывает каждую точку множества по отдельности.

Вторая также расчитывает множество, но уже четыре рядомстоящие точки одновременно, имметируя работу SIMD-функций.

Третья полноценно использует SIMD-функции при расчете множества, что оптимизирует процесс выполнения программы.

Далее было необходимо провести лабораторную работу, замерив время расчета множества каждой из функций, при этом в одной группе измерений, при компиляции программы, добавить флаг оптимизации -O3.

## В работе использовалось:
Сервер под управлением операционной системы Linux и процессором Intel.

Персональный компьютер под управлением операционной системы MacOS и процессором Apple M2 (ARM), на котором происходил вход и работа на сервере.

Функции по нахождения среднего значения - GetAvrVal (), среднеквадратичного отклонения - GetStdDev (), находящиеся в файле [lab_calcul_funcs.cpp](https://github.com/Pave2005/Mandelbrot/blob/main/lab_calcul_funcs.cpp).

## Ход работы:
Для расчета среднего времени расчета множества и среднеквадратичного отклонения было произведено 100 измерений времени по расчету множества для каждой программы. Результаты измерений представлены в таблице ниже.

|     version    | Compilation flags | Total time, sec | Avr time, sec |  Std dev, sec |
|:--------------:|:-----------------:|:---------------:|:-------------:|:-------------:|
|     Simple     |         -         |      24,49      |      0,244    |     0,008     |
|     Simple     |        -O3        |      13,97      |      0,140    |     0,004     |
|   Vectorized   |         -         |      67,84      |      0,678    |     0,055     |
|   Vectorized   |        -O3        |      6,39       |      0,064    |     0,007     |
| SIMD optimized |         -         |      18,64      |      0,186    |     0,034     |
| SIMD optimized |        -O3        |      3,79       |      0,038    |     0,001     |

Время работы функций было рассчитано с помощью функции библиотеки <time.h> clock () и с помощью макроса CLOCKS_PER_SEC.

Среднеквадратичное отклонении не составляет более 18% от среднего значения.

## Оценка результатов:
В первом случае время работы программы с флагом оптимизации уменьшилось в 1,7 раза, что подтверждает эффективность работы оптимизатора.

В случае с объединением расчета сразу четырех точек программа показала наихудший результат - почти 68 секунд, что может быть вызвано тем, что компилятор не смог усмотреть векторизованный расчет в функции. При этом после использования флага -03 время работы программы сократилось почти в 10 раз, что свидетельствует об оптимизации данной формы расчета.

При запуске программы, которая использует SIMD-функции, был получен наилучший результат как с использованием флага оптимизации, так и без него. В случае с использованием оптимизатора время расчета множества сократилось почти в 5 раз.

## Проблемы с которыми я столкнулся при получении результатов, используя флаг -O3:
При запуске всех трех программ с флагом оптимизации общее время работы программы уменьшилось на три порядка, в сравнение с теми результатами, которые я получал без использования -O3.

Проблема заключалась в том, что оптимизатор удалял фрагменты кода, где рассчитывались цвета точек множества, это происходило из-за того, что при подсчете времени работы, результаты этих вычислений никак не использовались из-за чего оптимизатор не видел смысла в их расчете.

### Как я решил эту проблему:
Для того, чтобы выйти из данной ситуации, я ввел дополнительную переменную ``` tmp ```, которая при каждом проходе цикла принимала в значение переменной с кодом цвета. Далее я функцией printf распечатывал ее значение. с помощью такого способа мне удалось избежать удаления оптимизатором расчета цветов множества.

## Выводы.
Оптимизации компилятора -O3 сильно влияет на время работы программы и в некоторых случаях уменьшает его в 10 раз. Самый плохой результат по времени без флага оптимизации показала векторизованная программа, в которой в цикле рассчитывались сразу 4 точки, это может быть связано с тем, что компилятор сам не смог оптимизировать эту часть. Как и ожидалось, программа с использованием SIMD-функций оказалось самой эффективной и показала наилучший результат как в обычном тесте, так и в тесте c флагом -O3.




